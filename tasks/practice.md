# Практические задания

В данном разделе вы найдете задания для практики, своеобразные этюды для
программистов, предназначенные для тренировки как навыком программирования, так
и навыков проведения исследовательской работы.

## Простой вычислитель

Постройте небольшой вычислитель арифметических выражений.  Начнём с таких
выражений: `((2+3)-4)`, `4`, `~((2*3)+(3*4))`.  Простановка скобок в выражениях
обязательна, и (`~`) означает унарный минус.  Для начала напишите функцию
разбора таких выражений, которая будет возвращать выражение, кодирующее в типах
Erlang данное выражение.  К примеру,

`{minus, {plus, {num, 2}, {num, 3}}, {num, 4}}`

означает `((2 + 3)-4)`.

Назовём такие выражения exps. Определите несколько функций:

 * вычислитель, который принимает выражение и возвращает его значение;
 * принтер, который преобразует выражение в строку;
 * компилятор, который преобразует выражение в последовательность действий
   стек-машины;
 * симулятор, который проводит вычисление последовательности действий
   стек-машины;
 * преобразователь, который упрощает выражение, так чтобы `0 * е` заменялось на
   0 и `1 * е` заменялось на е и многие другие правила преобразования выражений.

Также вы можете добавить условные выражения:

```
if ((2+3)-4) then 4 else ~((2*3)+(3*4))
```

Условные выражения возвращают значение после then, если значение выражения после
if равно нулю, и значение выражения после else в противном случае.

Также вы можете добавить локальные определения:

```
let с = ((2+3)-4) in ~((2*с)+(3*4))
```

Или вы можете добавить переменные, которые можно определять и затем использовать
во всех последующих выражениях.  Обратите внимание на то, как будут изменятся
уже определённые функции обработки выражений при добавлении новых конструкций.

## Потоковый механизм ответа web-server на Cowboy

* Скачайте и установите ``cowboy``  web-сервер, написанный на ``erlang``.
  Реализуйте модуль HTTP ответа, который будет возвращать ``200 OK`` для HTTP
  ``GET`` запросов на страницу ``http://localhost:8080/simple_response``.
  Используйте следующую
  [инструкцию](https://github.com/ninenines/cowboy/blob/master/doc/src/guide/getting_started.asciidoc)

* Дополнительно реализуйте модуль HTTP ответа, который будет возвращать ``200
  OK`` для HTTP ``GET`` запросов на страницу
  ``http://localhost:8080/chunked_response`` и выводить 10 chunk ответов типа
  ``chunk #1``, ``chunk #2``. Симулируйте работу каждого chunk функцией
  ``timer:sleet(1000)``. Используйте следующий
  [пример](https://github.com/ninenines/cowboy/tree/master/examples/chunked_hello_world)
  для старта работы

* Дополнительно переработайте модуль HTTP ответа ``chunked_response``, чтобы
  отделить логику выполнения запроса от логики посылки ответа (функция для
  отправки chunks ``cowboy_req:stream_body`` не должна вызывать в коде, где
  осуществляется подготовка тела chunk ответа). Подсказка: напишите
  lambda-функцию, которая будет принимать и выполнять ленивую функцию для
  генерации каждого chunk. В качестве одного из значений, что возвращает эта
  функция - функция, которая выполняет генерацию следующего chunk.

## Немного о ленивых вычисления и процессах

Если Вы немного думали над вопросом, а в чем заключается особая польза в функции
склеивания ленивых списков, то могли заметить наверняка, что это очень удобный
механизм инкапсуляции потоков данных из разных источников - мы можем читать
часть данных из файлов, часть из БД, но с точки зрения клиентской функции этот
поток данных выглядит единообразно. Ничто не мешает нам соединять мощь
абстракции ленивых потоков с мощностью процессов и параллельных вычислений.
Задача из реальной жизни: есть некоторый поток, в котором большие блоки
последовательно читаются из файлов. Чтение из файла - операция достаточно
дорогая (по сравнению с памятью), а обработка данных из этого файла также может
оказаться дорогой. Если мы все делаем последовательно, сначала читаем один блок,
а затем его обрабатываем, то это может сказаться на производительности системы.
В таком случае, процессы нам помогут делать это параллельно.  Ленивый поток
данных нам предоставляет удобную абстракцию потока данных, а процессы нам
помогают выполнить чтение кусков данных из файла параллельно их обработке, то
есть, когда после обработки одного куска данных мы запросим следующий кусок - мы
его уже получим немедленно, так как он уже в памяти, а процесс время от времени
одчитывает нужные блоки. Реализуйте этот подход. При этом для клиентского кода
не должно быть разницы между обычным ленивым списком и списком с кешированием.
