# Блок "Модель акторов, процессы"

# Database
За основу возьмите модуль db из предыдущего задания, оформите это в виде процесса. API примерно такой же, с небольшими изменениями:

```erlang
db:new() => Pid.  %% Возвращает pid созданного процесса.
```

```erlang
db:destroy(Db) => ok.

%% Убивает созданный процесс с помощью функции exit(Pid, Reason),
%% где Pid - это собственно идентификатор процесса, Reason - это некоторый терм, который
%% описывает причину прерывания работы процесса. В качестве Reason можно указать атом exit.
```

```erlang
db:write(Key, Element, Db) => ok | {error, Reason}. 

%% отметьте, что здесь мы возвращаем ok,
% если все хорошо, или кортеж {error, Reason}, если происходит какая-то ошибка.
% В качестве ошибочной ситуации можно привести пример, когда процесс базы данных уже убит,
% а мы пытаемся все еще что-то с ним делать. Для проверки, жив ли процесс или уже нет,
% можно использовать функцию `is_process_alive(Pid)`.
db:delete(Key, Db) => ok | {error, Reason}.
db:read(Key, Db) => {ok, Element} | {error, instance}.
db:match(Element, Db) => [Keyl, ..., KeyN].
```

Каждый процесс может иметь состояние, вспоминайте хвостовую рекурсию.
Воспользуйтесь идеей, приведенной ниже:

```erlang
proc(State) ->
    NewState = receive
        Msg ->
            %% ...какие то вычисления с термами Msg и State, возвращающие новое состояние NewState...
    end,
    proc(NewState).
```

## Процессоводство
 - Создайте кольцо процессов и запустите по нему некоторое сообщение. Сообщение (условно назовем его "маркер") должно пробежаться по кольцу M раз, после чего необходимо остановиться.

 - Усложним предыдущий пример: вместо кольца процессов создайте граф процессов (случайным образом, можете воспользоваться функциями из модуля random, который присутствует в стандартной библиотеке) и реализуйте алгоритм обхода этого графа с помощью пересылки сообщений. Выходные данные представить в виде информации о том, из каких компонент связности состоит данный граф. Организовать граф можно следующим образом: каждый процесс имеет список идентификаторов других процессов, которым он может послать сообщения.

 - Организуйте состязание между процессами, лотерею. Процессы должны между собой договориться, кто из них *всем процессам процесс*. Допустим, они договариваются, что у кого из них выпадет большее число (с помощью того же random), тот и главнее. Как организовывать в этом случае обмен сообщениями - все на ваше усмотрение.
Можно рассмотреть два варианта:
 - простой: ввести дополнительный процесс, назовем его croupier, он будет объявлять результаты лотереи и убивать неудачников.
 - сложный: как-то обойтись без крупье.
